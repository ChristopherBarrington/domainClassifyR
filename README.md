# domainClassifyR

## Installation

Please have 'misha' R package installed prior to running run_domainClassifyR.R, with a GENOME_DB configured (minimum example provided in example_data).

Install `domainClassifyR` using `devtools::github('ChristopherBarrington/domainClassifyR')`. Tested under Linux R 3.5.1 with:

```
 package         * version    date
 devtools        * 1.13.6     2018-06-27
 domainClassifyR * 0.0.0.9000 2018-11-02
 doMC              1.3.5      2017-12-12
 dplyr           * 0.7.7      2018-10-16
 ggplot2         * 3.1.0      2018-10-25
 magrittr          1.5        2014-11-22
 misha           * 4.0.4      2018-09-24
 plyr            * 1.8.4      2016-06-08
 purrr             0.2.5      2018-05-29
 scales            1.0.0      2018-08-09
 snow            * 0.4-2      2016-10-14
 tibble            1.4.2      2018-01-22
 tidyselect        0.2.5      2018-10-11
```

## Steps

### Getting contacts within 2D intervals

`get_contacts()` is used to query the `track_nm` score track to select all interacting fends within each 2D interval in `domains`. The data are saved into a list and cached in `cache.path` to quickly reload the same 2D interval.

- `domains` A data.frame of 2D intervals
- `track_nm` Name of the score track from which fend pairs are extracted
- `cache.path` Absolute path to the directory that cached domains can be found or saved (will be created)

All subsequent functions use the list of contacts returned by `get_contacts()` as input, specified in each by the `contacts` argument.

See `?get_contacts`

### Filtering and profiling contacts

Once the 2D intervals are cached, they are loaded into a list (one element per 2D interval). Subsequent characterisations of 2D intervals are required to format the data for sampling.

`add.domain.features()` appends information to the `DOMAIN` element and to the all contacts data.frame: the sizes of the 2 intervals are recorded as well as the position in `resolution` bins of the scored fend pair relative to the start and end of the 2D interval. Interactors (high-score fend pairs) with a bin position of 0 would be considered as leading- or trailing-edge).

- `resolution` The size in bp of the trailing- or leading- edge (and therefore the size of the interval 'corner')

`get.high.score.fends()` duplicates the `ALL` contacts data.frame, selecting only those fend pairs with score above `min_score` into the `HIGH_SCORE` element.

- `min_score` The minimum score for which fend pairs are considered interactors

`count.contacts()` is used to count the number of contact pairs in the 2D interval (and takes no arguments beyond the `contacts` list). 

`get.domain.position.classification()` calculates the number of contacts (and interactors) in each sector of each 2D interval using the binned positions of contacts from the `add.domain.features` function and the `resolution` parameter. The function also calculates the number of interactors in a sector as a proportion of all contacts in the 2D interval (`$FEND.SCORE.DISTRIBUTION$SCORES_dHS_mALL`) and of the total number of interactors (`$FEND.SCORE.DISTRIBUTION$SCORES_dALL_mHS`). This function takes no arguments beyond the `contacts` list.

See `?add.domain.features`, `?get.high.score.fends`, `?count.contacts`, `?get.domain.position.classification`

### Randomly sampling high-score intra-interval contacts

The contacts within each 2D interval are then randomly sampled to generate a random distribution of contacts within each sector that can be compared to the observed number of interactors in each sector. `get.fend.samples()` is used to randomly select contacts (ignoring score) and count how many of the randomly selected contacts are positioned in each of the four sectors. The number of contacts sampled (using `R` `sample()`) is determined by the number of interactors. The distribution is generated by repeating the sampling process `n` times; a data.frame of `n` rows is produced with each column showing the number of randomly selected contacts in a sector (`$CONTACTS$RANDOM_SAMPLE_TABLES`). The process can be parallelised using the `doMC` package and the `cluster_size` parameter to determine the number of parallel threads. For reproducibility a seed can be set, which is determined by the 2D interval ID - expecting an ID of `12:34` the seed would be `1234`.

- `random_seed` Boolean whether to use the intervalID to set a seed
- `n` number of times to repeat the sampling process
- `cluster_size` number of parallel threads to run or `1` for no parallelisation

See `?get.fend.samples`

### Compute Z-scores for each sector of each 2D interval

Using the number of sampled contacts per sector, `get_Z_statistics()` calculates the mean and standard deviation of the sector distributions which are used with the number of observed interactors to calculate a Z-score for each sector (of each 2D interval). This is saved into `$Z_STATISTICS`. Z-scores are converted to p-values using `pnorm` (`P`). `get_min_fend_pair_domains()` is used to filter the 2D interval set, requiring that an interval pair has at least `min` interactors. Multiple testing is then corrected for using `get_Q_values()`. The 2D intervals set is collapsed to a data such that each row is a filtered 2D interval and each column is `P` for each sector in the 2D interval. Each column is corrected using the method specified by `method` which is passed to `p.adjust()`.

- `min` Minimum number of contacts or interactors required in a domain
- `measure` Should be `'HIGH_SCORE'` or `'ALL'` to determine which contact set is filtered by
- `method` The correction method to apply, see `?p.adjust`

See `?get_Z_statistics`, `?get_min_fend_pair_domains`, `?get_Q_values`

## MWE:

Using example data, script should complete in minutes.

```
library(misha)
library(domainClassifyR)

# set the misha GENOME_DB root (eg to the mm10 directory included in the example_data [get ftp link])
gsetroot('/absolute/path/to/GENOME_DB/mm10/')

# load data / set parameters
intervals_2d <- gintervals.load("intervs.chr19_domains")
track_nm <- 'hic.example_project.example_dataset.tracks.score'
cache_path <- file.path(getwd(), 'domainclassifyr_cache')

# run the parts of the package
contacts <- get_contacts(domains=intervals_2d,
                         track_nm=track_nm,
                         cache.path=cache_path,
                         band=c(10e3,15e6),
                         get.fends=FALSE)
contacts <- add.domain.features(contacts, resolution=60e3)
contacts <- get.high.score.fends(contacts, min_score=40)
contacts <- count.contacts(contacts)
contacts <- get.domain.position.classifications(contacts)
contacts <- get.fend.samples(contacts, n=1000)
contacts <- get_Z_statistics(contacts)
contacts <- get_min_fend_pair_domains(contacts, min=100)
contacts <- get_Q_values(contacts)

# get a data.frame of qvalues for each sector of the domain
> ldply(contacts, function(d) d$Z_STATISTICS$OBSERVED$Q) %>% tibble::as.tibble()
# # A tibble: 77 x 5
#    .id         CORNER  FORWARD   REVERSE    OTHER
#    <chr>        <dbl>    <dbl>     <dbl>    <dbl>
#  1 2012:2012 1.00e+ 0 1.48e- 4 0.        1.00e+ 0
#  2 2013:2013 1.00e+ 0 1.00e+ 0 1.00e+  0 3.30e-21
#  3 2015:2015 1.00e+ 0 4.75e-65 1.00e+  0 1.00e+ 0
#  4 2017:2017 1.32e-52 1.00e+ 0 8.29e-  2 8.92e- 1
#  5 2019:2019 1.27e- 8 1.00e+ 0 9.79e-209 1.00e+ 0
#  6 2021:2021 4.54e-14 3.54e- 3 1.00e+  0 1.00e+ 0
#  7 2022:2022 1.00e+ 0 1.00e+ 0 1.00e+  0 6.35e-60
#  8 2023:2023 1.00e+ 0 1.00e+ 0 1.00e+  0 1.33e-11
#  9 2024:2024 4.34e-62 1.00e+ 0 1.15e-186 1.00e+ 0
# 10 2026:2026 5.88e-55 2.54e-25 1.00e+  0 1.00e+ 0
# # ... with 67 more rows

# plot the contacts in one domain
ggplot2::ggplot(contacts[['2106:2106']]$CONTACTS$HIGH_SCORE)+
  aes(x=FEND.X,y=FEND.Y,colour=SCORE)+
  geom_point(shape=20)+coord_fixed()+theme(aspect.ratio=1)
```
